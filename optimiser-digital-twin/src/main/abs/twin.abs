// A digital twin to replay recorded traces from the real system on varying
// deployments, and emit traces in the same format.
//
// We use the following databases, all of which must be present in the current
// directory:
//
// - `trace.db`: contains one table `trace_events` with one entry per trace
//   event that should be replayed. Can be created from a file of recorded
//   traces by the `import-traces` sub-command.
//
// - `scenario.db`: contains one table `scenario` that contains deployment
//   component size and count for each component.  Can be created from an app
//   creation message file and (optionally) a solver solution message file by
//   the `import-deployment` sub-command.
//
// - `calibration.db`: contains one table `factors` with the constant
//   (duration) and variable (cost) factors for each component.

module Twin;
import * from ABS.DC;

// Database-related types

def List<Int> minEventTime__() =
    builtin(sqlite3, "trace.db", "SELECT min(event_time) FROM trace_events");

// Return the time of the first event.  This is used as the offset between the
// ABS logical clock and the trace event times.  (See `eventJsonl`.)
def Int minEventTime() = head(minEventTime__());

data DBNode = DBNode(String nodeName, Int nodeCpu, Int nodeMemory, Int nodeReplicas);

// All components (nodes).  TODO: figure out what to do with remote-only
// nodes, e.g. a database node that we don't instrument
def List<DBNode> allNodes() =
    builtin(sqlite3, "scenario.db",
            `SELECT component, cpu, memory, replicas FROM scenario`);

// all activity IDs
def List<String> activities() =
    builtin(sqlite3, "trace.db",
            "SELECT DISTINCT activity_id FROM trace_events");

data Event = Event(String eventLocalComponent, String eventLocalId,
                   String eventRemoteComponent,
                   String eventActivityId, String eventType,
                   Int eventTime, Int eventPayloadSize);

// Generate a jsonl line (JSON object) for the event at the current time.
//
// Note that since we start with time t=0 when replaying events, we use `now()
// + minTime` instead of just the current time.  This means that recorded and
// replayed trace start at the same time point (but events after the first
// ones will occur at different times).
def String eventJsonl(Event event, Int minTime) =
    `{"CompName":"$eventLocalComponent(event)$","ReplicaID":"$eventLocalId(event)$","EventType":"$eventType(event)$","EventTime":$timeValue(now()) + minTime$,"PayloadSize":$eventPayloadSize(event)$,"ActivityID":"$eventActivityId(event)$","RemoteCompName":"$eventRemoteComponent(event)$"}`;

// All trace events of activity with id `activityId`, ordered by time
def List<Event> activityTrace(String activityId) =
    builtin(sqlite3, "trace.db",
            `SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events
              WHERE activity_id = ?
              ORDER BY event_time ASC`,
            activityId);

// The starting events of activity with id `activityId`.
def List<Event> startingEvents(String activityId) =
    builtin(sqlite3, "trace.db",
            `SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events a
              WHERE activity_id = ?
                AND event_type = 'out'
                AND NOT EXISTS
                    (SELECT * FROM trace_events b
                      WHERE b.activity_id = a.activity_id
                        AND ((b.event_type = 'in' OR b.event_type = 'ack')
                             AND b.local_name = a.local_name
                             AND b.local_id = a.local_id)
                        AND b.event_time < a.event_time)`,
            activityId);

// The outgoing events caused by `in_event`.  Can be more than one event.
def List<Event> outgoingEventsForIncoming(Event in_event) =
    builtin(sqlite3, "trace.db",
            `WITH
               activity_id AS (SELECT ?),
               local_event_name AS (SELECT ?),
               local_event_id AS (SELECT ?),
               local_event_time AS (SELECT ?),
               remote_event_name AS (SELECT ?),
               upper_time_bound AS (
                 SELECT MIN(event_time)
                   FROM trace_events
                  WHERE activity_id = (SELECT * FROM activity_id)
                    AND local_name = (SELECT * FROM local_event_name)
                    AND local_id = (SELECT * FROM local_event_id)
                    AND (event_type = 'in' OR event_type = 'ack')
                    AND event_time > (SELECT * FROM local_event_time))
             SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events
              WHERE activity_id = (SELECT * FROM activity_id)
                AND (event_type = 'out'
                     AND local_name = (SELECT * FROM local_event_name)
                     AND local_id = (SELECT * FROM local_event_id))
                AND event_time > (SELECT * FROM local_event_time)
                AND event_time < COALESCE((SELECT * FROM upper_time_bound), event_time + 1)`,
            eventActivityId(in_event),
            eventLocalComponent(in_event),
            eventLocalId(in_event),
            eventTime(in_event),
            eventRemoteComponent(in_event));

// The incoming event corresponding to the given `out_event`.  Can be an event
// of type 'in' or 'ack'.  This function should always return a list of one
// event (if the recorded trace is well-formed), since we don't do broadcast
// events.
def List<Event> incomingEventForOutgoing(Event out_event) =
    builtin(sqlite3, "trace.db",
            // Lots of superfluous WITH subqueries; we could pass in
            // some of the arguments multiple times but this is a bit
            // more readable
            `WITH
               activity_id AS (SELECT ?),
               local_event_name AS (SELECT ?),
               local_event_id AS (SELECT ?),
               local_event_time AS (SELECT ?),
               remote_event_name AS (SELECT ?),
               upper_time_bound AS (
                 SELECT MIN(event_time)
                   FROM trace_events
                  WHERE activity_id = (SELECT * FROM activity_id)
                    AND local_name = (SELECT * FROM local_event_name)
                    AND local_id = (SELECT * FROM local_event_id)
                    AND event_type = 'out'
                    AND event_time > (SELECT * FROM local_event_time))
             SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events
              WHERE activity_id = (SELECT * FROM activity_id)
                AND (event_type = 'in'
                     AND local_name = (SELECT * FROM remote_event_name)
                     AND remote_name = (SELECT * FROM local_event_name)
                     OR event_type = 'ack'
                     AND local_name = (SELECT * FROM local_event_name)
                     AND remote_name = (SELECT * FROM remote_event_name))
                AND event_time > (SELECT * FROM local_event_time)
                AND event_time < COALESCE((SELECT * FROM upper_time_bound), event_time + 1)`,
            eventActivityId(out_event),
            eventLocalComponent(out_event),
            eventLocalId(out_event),
            eventTime(out_event),
            eventRemoteComponent(out_event));

// The event processing costs for each component.
data CalibrationEntry = CalibrationEntry(String entryName, Rat entryConstant, Rat entryVariable);

def List<CalibrationEntry> componentCosts() =
    builtin(sqlite3, "calibration.db",
            "SELECT component, constant_cost, variable_cost FROM factors");

def Map<String, Rat> componentConstantFactors() =
    foldl((CalibrationEntry e, Map<String, Rat> m) =>
          put(m, entryName(e), entryConstant(e)))
    (componentCosts(), map[]);

def Map<String, Rat> componentVariableFactors() =
    foldl((CalibrationEntry e, Map<String, Rat> m) =>
          put(m, entryName(e), entryVariable(e)))
    (componentCosts(), map[]);

// Model nodes

interface Component {
    Unit execute(Int cost);
}
class Component(String name,
                Int replicaId,
                Rat constantFactor,
                Rat variableFactor)
    implements Component
{
    Unit execute(Int cost) {
        await duration(constantFactor);
        [Cost: cost * variableFactor] skip;
    }
}

interface Activity {
}

class Activity(String activityId, Map<String, List<Component>> components)
    implements Activity
{
    Int minEventTime = minEventTime();
    Int eventsInFlight = 0;     // If 0, activity has finished / hasn't started yet

    Unit run() {
        List<Event> pendingEvents = startingEvents(activityId);
        foreach (event in startingEvents(activityId)) {
            this!processStartingEvent(event, eventTime(event) - minEventTime);
        }
    }

    Unit processStartingEvent(Event event, Int delay) {
        await duration(delay);
        this!processEvent(event);
    }

    Unit processEvent(Event event) {
        eventsInFlight = eventsInFlight + 1;
        // TODO: generate Event from what actually happened; do not echo input
        // trace here, otherwise we don't see the right ReplicaID values
        println(eventJsonl(event, minEventTime));
        switch (eventType(event)) {
            "out" => {
                List<Event> followingEvents = incomingEventForOutgoing(event);
                if (!isEmpty(followingEvents)) {
                    // should be only one event, since we don't
                    // broadcast (do we?), but can be empty in case of
                    // incomplete trace
                    Event followingEvent = head(followingEvents);
                    Int t = eventTime(followingEvent) - eventTime(event);
                    await duration(t);
                    this!processEvent(followingEvent);
                }
            }
            _ => {
                // "in" or "ack"
                List<Event> resultingEvents = outgoingEventsForIncoming(event);
                Rat meanTime =
                  when length(resultingEvents) > 0
                  then foldl((Event e, Int acc) => acc + eventTime(e) - eventTime(event))(resultingEvents, 0)
                    / length(resultingEvents)
                  else 0;
                List<Component> cl = lookupDefault(components, eventLocalComponent(event), Nil);
                // Choose random replica for this component for now
                Maybe<Component> c = when cl == Nil then Nothing else Just(nth(cl, random(length(cl))));
                foreach (e in resultingEvents) {
                    Int t = eventTime(e) - eventTime(event);
                    if (isJust(c)) { // should always be true
                        await fromJust(c)!execute(t);
                    }
                    this!processEvent(e);
                }
            }
        }
        eventsInFlight = eventsInFlight - 1;
    }
}

{
    Map<String, Rat> constantFactors = componentConstantFactors();
    Map<String, Rat> variableFactors = componentVariableFactors();
    Map<String, List<Component>> components = map[];
    foreach (nodetype in allNodes()) {
        List<Component> nodeComponents = Nil;
        foreach (nodeId in range(1, nodeReplicas(nodetype))) {
            DeploymentComponent dc = null;
            String nodeName = nodeName(nodetype);
            // If the factors are unspecified (should not happen), assume only
            // constant delays.
            Rat constantFactor = lookupDefault(constantFactors, nodeName, 1);
            Rat variableFactor = lookupDefault(variableFactors, nodeName, 0);
            if (nodeCpu(nodetype) > 0) {
                dc = new DeploymentComponent(`$nodeName(nodetype)$-$nodeId$`, map[Pair(Speed, nodeCpu(nodetype) * 10)]);
            } else {
                // TODO: Unspecified node size, read node default values from somewhere
                dc = new DeploymentComponent(`$nodeName(nodetype)$-$nodeId$`, map[Pair(Speed, 10)]);
            }
            [DC: dc] Component component = new Component(nodeName, nodeId, constantFactor, variableFactor);
            nodeComponents = Cons(component, nodeComponents);
        }
        components = put(components, nodeName(nodetype), nodeComponents);
    }
    List<Activity> activityObjects = Nil;
    List<String> activities = activities();
    foreach (activity_id in activities) {
        Activity a = new Activity(activity_id, components);
        activityObjects = Cons(a, activityObjects);
    }
}

// Local Variables:
// abs-target-language: java
// abs-java-output-jar-file: "twin.jar"
// End:
