// A digital twin to replay recorded traces from the real system on varying
// deployments, and emit traces in the same format.
//
// We use two databases, both of which must be present in the current directory:
//
// - `trace.db`: contains one table `trace_events`, can be created from a file
//   of recorded traces by the `import-traces` sub-command.
//
// - `scenario.db`: contains one table `scenario`, can be created from an app
//   creation message file and (optionally) a solver solution message file by
//   the `import-deployment` sub-command.

module Twin;
import * from ABS.DC;

// Database-related types

data DBNode = DBNode(String nodeName, Int nodeCpu, Int nodeMemory, Int nodeReplicas);

def List<Int> minEventTime__() =
    builtin(sqlite3, "trace.db", "SELECT min(event_time) FROM trace_events");

def Int minEventTime() = head(minEventTime__());

// All components (nodes).  TODO: figure out what to do with remote-only
// nodes, e.g. a database node that we don't instrument
def List<DBNode> allNodes() =
    builtin(sqlite3, "scenario.db",
            `SELECT component, cpu, memory, replicas FROM scenario`);

// all activity IDs
def List<String> activities() =
    builtin(sqlite3, "trace.db",
            "SELECT DISTINCT activity_id FROM trace_events");

data Event = Event(String eventLocalComponent, String eventLocalId,
                   String eventRemoteComponent,
                   String eventActivityId, String eventType,
                   Int eventTime, Int eventPayloadSize);

def String eventJsonl(Event event, Int minTime) =
    // Generate a jsonl line with the event, but use now() + minTime
    // instead of the "ground truth" of the trace.  We pass in minTime
    // so that we don't have to call `minEventTime()` every time.
    `{"CompName":"$eventLocalComponent(event)$","ReplicaID":"$eventLocalId(event)$","EventType":"$eventType(event)$","EventTime":$timeValue(now()) + minTime$,"PayloadSize":$eventPayloadSize(event)$,"ActivityID":"$eventActivityId(event)$","RemoteCompName":"$eventRemoteComponent(event)$"}`;

// All trace events of given activity, ordered by time
def List<Event> activityTrace(String activityId) =
    builtin(sqlite3, "trace.db",
            `SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events
              WHERE activity_id = ?
              ORDER BY event_time ASC`,
            activityId);

def List<Event> startingEvents(String activityId) =
    builtin(sqlite3, "trace.db",
            `SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events a
              WHERE activity_id = ?
                AND event_type = 'out'
                AND NOT EXISTS
                    (SELECT * FROM trace_events b
                      WHERE b.activity_id = a.activity_id
                        AND ((b.event_type = 'in' OR b.event_type = 'ack')
                             AND b.local_name = a.local_name
                             AND b.local_id = a.local_id)
                        AND b.event_time < a.event_time)`,
            activityId);

def List<Event> outgoingEventsForIncoming(Event in_event) =
    builtin(sqlite3, "trace.db",
            `WITH
               activity_id AS (SELECT ?),
               local_event_name AS (SELECT ?),
               local_event_id AS (SELECT ?),
               local_event_time AS (SELECT ?),
               remote_event_name AS (SELECT ?),
               upper_time_bound AS (
                 SELECT MIN(event_time)
                   FROM trace_events
                  WHERE activity_id = (SELECT * FROM activity_id)
                    AND local_name = (SELECT * FROM local_event_name)
                    AND local_id = (SELECT * FROM local_event_id)
                    AND (event_type = 'in' OR event_type = 'ack')
                    AND event_time > (SELECT * FROM local_event_time))
             SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events
              WHERE activity_id = (SELECT * FROM activity_id)
                AND (event_type = 'out'
                     AND local_name = (SELECT * FROM local_event_name)
                     AND local_id = (SELECT * FROM local_event_id))
                AND event_time > (SELECT * FROM local_event_time)
                AND event_time < COALESCE((SELECT * FROM upper_time_bound), event_time + 1)`,
            eventActivityId(in_event),
            eventLocalComponent(in_event),
            eventLocalId(in_event),
            eventTime(in_event),
            eventRemoteComponent(in_event));

// For an 'out' (leaves a component) trace event, find the
// corresponding 'in' or 'ack' event.  The return value should always
// contain one event.
def List<Event> incomingEventForOutgoing(Event out_event) =
    builtin(sqlite3, "trace.db",
            // Lots of superfluous WITH subqueries; we could pass in
            // some of the arguments multiple times but this is a bit
            // more readable
            `WITH
               activity_id AS (SELECT ?),
               local_event_name AS (SELECT ?),
               local_event_id AS (SELECT ?),
               local_event_time AS (SELECT ?),
               remote_event_name AS (SELECT ?),
               upper_time_bound AS (
                 SELECT MIN(event_time)
                   FROM trace_events
                  WHERE activity_id = (SELECT * FROM activity_id)
                    AND local_name = (SELECT * FROM local_event_name)
                    AND local_id = (SELECT * FROM local_event_id)
                    AND event_type = 'out'
                    AND event_time > (SELECT * FROM local_event_time))
             SELECT local_name, local_id, remote_name, activity_id, event_type, event_time, payload_size
               FROM trace_events
              WHERE activity_id = (SELECT * FROM activity_id)
                AND (event_type = 'in'
                     AND local_name = (SELECT * FROM remote_event_name)
                     AND remote_name = (SELECT * FROM local_event_name)
                     OR event_type = 'ack'
                     AND local_name = (SELECT * FROM local_event_name)
                     AND remote_name = (SELECT * FROM remote_event_name))
                AND event_time > (SELECT * FROM local_event_time)
                AND event_time < COALESCE((SELECT * FROM upper_time_bound), event_time + 1)`,
            eventActivityId(out_event),
            eventLocalComponent(out_event),
            eventLocalId(out_event),
            eventTime(out_event),
            eventRemoteComponent(out_event));

// Model nodes

interface Component {
    Unit execute(Int cost);
}
class Component(String name, Int replicaId) implements Component {
    Unit execute(Int cost) {
        [Cost: cost] skip;
    }
}

interface Activity {
}

class Activity(String activityId, Map<String, List<Component>> components)
    implements Activity
{
    Int minEventTime = minEventTime();
    Int eventsInFlight = 0;     // If 0, activity has finished / hasn't started yet

    Unit run() {
        List<Event> pendingEvents = startingEvents(activityId);
        foreach (event in startingEvents(activityId)) {
            this!processStartingEvent(event, eventTime(event) - minEventTime);
        }
    }

    Unit processStartingEvent(Event event, Int delay) {
        await duration(delay);
        this!processEvent(event);
    }

    Unit processEvent(Event event) {
        eventsInFlight = eventsInFlight + 1;
        // TODO: generate Event from what actually happened; do not echo input
        // trace here, otherwise we don't see the right ReplicaID values
        println(eventJsonl(event, minEventTime));
        switch (eventType(event)) {
            "out" => {
                List<Event> followingEvents = incomingEventForOutgoing(event);
                if (!isEmpty(followingEvents)) {
                    // should be only one event, since we don't
                    // broadcast (do we?), but can be empty in case of
                    // incomplete trace
                    Event followingEvent = head(followingEvents);
                    Int t = eventTime(followingEvent) - eventTime(event);
                    await duration(t);
                    this!processEvent(followingEvent);
                }
            }
            _ => {
                // "in" or "ack"
                List<Event> resultingEvents = outgoingEventsForIncoming(event);
                Rat meanTime =
                  when length(resultingEvents) > 0
                  then foldl((Event e, Int acc) => acc + eventTime(e) - eventTime(event))(resultingEvents, 0)
                    / length(resultingEvents)
                  else 0;
                List<Component> cl = lookupDefault(components, eventLocalComponent(event), Nil);
                // Choose random replica for this component for now
                Maybe<Component> c = when cl == Nil then Nothing else Just(nth(cl, random(length(cl))));
                foreach (e in resultingEvents) {
                    Int t = eventTime(e) - eventTime(event);
                    if (isJust(c)) { // should always be true
                        await fromJust(c)!execute(t);
                    }
                    this!processEvent(e);
                }
            }
        }
        eventsInFlight = eventsInFlight - 1;
    }
}

{
    Map<String, List<Component>> components = map[];
    foreach (nodetype in allNodes()) {
        List<Component> nodeComponents = Nil;
        foreach (nodeId in range(1, nodeReplicas(nodetype))) {
            Component component = null;
            if (nodeCpu(nodetype) > 0) {
                DeploymentComponent dc = new DeploymentComponent(`$nodeName(nodetype)$-$nodeId$`, map[Pair(Speed, nodeCpu(nodetype) * 10)]);
                [DC: dc]component = new Component(nodeName(nodetype), nodeId);
            } else {
                // TODO: unspecified node size, read node default values from somewhere
                DeploymentComponent dc = new DeploymentComponent(`$nodeName(nodetype)$-$nodeId$`, map[Pair(Speed, 10)]);
                [DC: dc]component = new Component(nodeName(nodetype), nodeId);
            }
            nodeComponents = Cons(component, nodeComponents);
        }
        components = put(components, nodeName(nodetype), nodeComponents);
    }
    List<Activity> activityObjects = Nil;
    List<String> activities = activities();
    foreach (activity_id in activities) {
        Activity a = new Activity(activity_id, components);
        activityObjects = Cons(a, activityObjects);
    }
}

// Local Variables:
// abs-target-language: java
// abs-java-output-jar-file: "twin.jar"
// End:
